#include <stdio.h>
#include <iostream>
using namespace std;

/*
一个音乐搜索引擎，用户输入一首乐曲Q、一个正整数k。从音乐库中查找与Q最相似的k首乐曲。乐曲由一组正整数组成，每个正整数表示声音的频率。计算乐曲相似度的方法是直方图方法。下面是详细的计算过程。
第一步，将整个频率的取值区域（[0, 255]）均分为16个子区域，即[0,15]、 [16,31]、……、 [240, 255]。扫描一首乐曲，计算组成该乐曲的所有频率值出现在每个子区域的次数。例如一首乐曲M1由4个频率组成10、12、245、245，则它的直方图就是
[0, 15]:2
[16, 31]:0
……
[240, 255]:2
即，该乐曲的频率在[0, 15]和[240, 255]这两个子区域各出现2次，其他子区域均出现0次。
第二步，分别得到两个乐曲M1和M2的直方图之后，将两个直方图看作两个向量，采用欧几里得公式计算两个直方图的距离。
欧几里得公式：给定两个向量 v1=[x1,x2, …, xn]，以及 v2=[y1,y2, …, yn], 它们的欧几里得距离为  sqrt((x1-y1)2 + (x2-y2)2 + …… + (xn-yn)2)
例如，若另一首乐曲 M2 的直方图为
[0, 15]:2
[16,31]:0
……
[240,255]:0
则 M1和 M2 的欧几里得距离为 sqrt( (2-2)2 +0 + … + (0-2)2) = 2
所谓“与Q最相似的k首乐曲”，即与Q的欧几里得距离最小的前k首乐曲。
【输入格式】
?	第1行，表示查询乐曲，一个正整数n0（1≤n0≤100）, 表示乐曲长度，后面有 n0 个整数，每个整数在[0, 255]内，表示一个频率。
?	第2行，两个整数n和k，用空格隔开。表示有n首乐曲，1≤n≤100，查找最相似的k (1≤k≤n)首乐曲。
?	第3行到n+2行，表示编号从0到n-1的n首乐曲。每行一个正整数ni (1≤ni≤100), 表示该乐曲长度，后面ni个整数，每个整数在[0, 255]内，表示一个频率。
【输出格式】
输出k个整数，与查询乐曲最相似的乐曲的编号，注意乐曲编号范围是[0, n-1]。按相似度从高到低（即：欧式距离从小到大）的顺序输出。若两首乐曲与Q的距离相同，则编号小的排名靠前。

【输入样例】
4 10 12 245 245
3 1
6 2 4 2 250 250 250
1 189
4 10 12 245 245
【输出样例】
2

*/

#if 1

#include <stdio.h>
#include <math.h>
int main() {
	int n, k, n0, i, j, count0[16] = {0}, m;
	int a[100], b[100][3], d[100][100], count[100][16] = {0}; //a存曲子
	float sim[100];//c[i]存相似度

	scanf("%d", &n0); //曲长
	for (i = 0; i < n0; i++)
		scanf("%d", &a[i]);
	scanf("%d %d", &n, &k); //n首曲子找k个最相近

	for (i = 0; i < n; i++)
		b[i][2] = i; //编号
	for (i = 0; i < n; i++) {
		scanf("%d", &b[i][1]);
		for (j = 0; j < b[i][1]; j++)
			scanf("%d", &d[i][j]);
	}

	for (i = 0; i < 16; i++)
		for (j = 0; j < n0; j++) {
			if ( a[j] >= 0 + i * 16 && a[j] <= 15 + i * 16 )
				count0[i]++;//识别曲每个区间里的频率
		}

	for (i = 0; i < n; i++)
		for ( j = 0; j < 16; j++ )
			for (m = 0; m < b[i][1]; m++) {
				if ( d[i][m] >= 0 + j * 16 && d[i][m] <= 15 + 16 * j )
					count[i][j]++;//每首曲子每个区间的频率
			}
	//上面的可以简化换成如下的
	//for (i=0;i<n;i++)
	//   for(m=0; m<b[i][1]; m++){
	//       j=d[i][m]%16
	//       count[i][j]++;//每首曲子每个区间的频率
	//      }

	int sum;
	for (i = 0; i < n; i++) {
		sum = 0;
		for (j = 0; j < 16; j++)
			sum = sum + (count0[j] - count[i][j]) * (count0[j] - count[i][j]);
		sim[i] = sqrt(sum); //第i首曲子的相似度
	}

	float max;
	int t;
	for (i = 0; i < n - 1; i++)
		for (j = 0; j < n - 1 - i; j++)
			if (sim[j] > sim[j + 1] || ( (abs(sim[j + 1] - sim[j]) < 1e-6) && b[j][2] > b[j + 1][2]) ) {
				max = sim[j];
				sim[j] = sim[j + 1];
				sim[j + 1] = max;
				t = b[j][2];
				b[j][2] = b[j + 1][2];
				b[j + 1][2] = t;
			}

	for (i = 0; i < k; i++)
		printf("%d ", b[i][2]); //要有空格
	return 0;
}

#endif
